Executor框架可以将任务的提交和执行策略解耦,但是如果你提交的任务依赖于其他的任务,你就隐式的执行策略带来了约束,可能就会产生线程活跃度的问题
线程池的大小一般不会硬编码定制,池的长度应该由某种配置机制来提供或者利用Runtime.availableProcessors(CPU数目)结果,动态计算
池的最优大小: CPU数量 * 目标CPU使用率 * (1 + 等待时间与计算时间比)
配置ThreadPoolExecutor:
核心池大小 最大池大小 存活时间共同管理线程的创建和销毁
核心池大小是目标的大小,即使没有任务执行,池的大小也等于核心池大小
最大池大小是可同时活动的线程数上限
ThreadPoolExecutor还允许通过一个队列来持有等待执行的任务
饱和策略:队列满后或者任务提交到一个已经被关闭的Executor时候会启动饱和策略
    遗弃:放弃这个任务
    遗弃最旧的:放弃最旧的任务,试图将这个任务再次放入其中
    调用者运行:不会放弃任何一个任务,也不会抛出异常,直接推回任务
线程工厂:可能有些时候你需要追踪信息或者其他特别的需求,这个时候你可以通过自定义一个线程工厂(实现ThreadFactory)
ThreadPoolExecutor是可扩展的,子类复写beforeExecutor,afterExecutor和terminate即可